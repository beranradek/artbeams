package org.xbery.artbeams.common.security;

/*
 * Created on 26.6.2012
 */

import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.util.Base64;

/**
 * Pomocna trida pro vytvareni a overovani hashovanych hesel.
 *
 *  Whole password hash is generated by principle:
 *    gen. salt + gen. hash, whole cropped to (length = gen. hash constant length + DIGEST_LENGTH_EXTENSION) bytes.
 *
 * @version 3 - improvement: attacker cannot guess salt length
 */
public class PasswordHashing {
    // A 64 bits salt is recommended in RSA PKCS5 standard
    private static final int SALT_LENGTH = 8;
    // whole password hash is generated by principle as described above
    private static final int DIGEST_LENGTH_EXTENSION = 3;

    // you cannot change this without making all passwords invalid
    private static final String DIGEST_ALGORITHM = "SHA-512";

    public String createPasswordHash(String password) {
        if (password == null || password.trim().length() == 0) {
            return null;
        }
        MessageDigest md;
        try {
            md = MessageDigest.getInstance(DIGEST_ALGORITHM);
        } catch (NoSuchAlgorithmException e) {
            throw new IllegalStateException("error initializing MessageDigest: " + e.getMessage(), e);
        }
        // whole password hash length will be md.getDigestLength() + DIGEST_LENGTH_EXTENSION
        int hashLength = md.getDigestLength() + DIGEST_LENGTH_EXTENSION - SALT_LENGTH;

        byte[] hpwd = new byte[SALT_LENGTH + hashLength];

        SecureRandom sr;
        try {
            sr = SecureRandom.getInstance("SHA1PRNG");
        } catch (NoSuchAlgorithmException e) {
            throw new IllegalStateException("error initializing SecureRandom: " + e.getMessage(), e);
        }
        byte[] salt = new byte[SALT_LENGTH];
        sr.nextBytes(salt);
        System.arraycopy(salt, 0, hpwd, 0, SALT_LENGTH); // copy the salt
        md.update(salt);

        byte[] passwordBytes = password.getBytes(StandardCharsets.UTF_8);

        md.update((byte)hashLength); // include hash-length in the hash computation to be able to detect hash truncation
        md.update(passwordBytes);

        byte[] hash = md.digest();
        System.arraycopy(hash, 0, hpwd, SALT_LENGTH, hashLength);

        return Base64.getEncoder().encodeToString(hpwd);
    }

    public boolean verifyPasswordHash(String passwHash, String password) {
        if (passwHash == null || password == null || passwHash.trim().length() == 0) return false;

        byte[] pwdHash = Base64.getDecoder().decode(passwHash.getBytes(StandardCharsets.UTF_8));
        // check if salt length is too big - either truncated data or some
        if (SALT_LENGTH >= pwdHash.length)
            // random garbage
            return false;

        MessageDigest md;
        try {
            md = MessageDigest.getInstance(DIGEST_ALGORITHM);
        } catch (NoSuchAlgorithmException e) {
            throw new IllegalStateException("error initializing MessageDigest: " + e.getMessage(), e);
        }
        // add salt
        md.update(pwdHash, 0, SALT_LENGTH);
        // whole password hash length (pwdHash.length) will be md.getDigestLength() + DIGEST_LENGTH_EXTENSION, where first is salt
        int hashLength = pwdHash.length - SALT_LENGTH;
        if (hashLength == 0) // truncated data
            return false;

        byte[] passwordBytes = password.getBytes(StandardCharsets.UTF_8);
        md.update((byte)hashLength); // include hash-length in the hash computation to be able to detect hash truncation
        md.update(passwordBytes);

        byte[] hash = md.digest();

        // compare hash result
        for (int i = 0; i < hashLength; i++)
            if (hash[i] != pwdHash[SALT_LENGTH + i]) return false;

        return true;
    }
}
