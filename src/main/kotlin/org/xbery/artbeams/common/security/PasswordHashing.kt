package org.xbery.artbeams.common.security

import java.security.NoSuchAlgorithmException
import java.lang.IllegalStateException
import java.nio.charset.StandardCharsets
import java.security.MessageDigest
import java.security.SecureRandom
import java.util.*

/**
 * Pomocna trida pro vytvareni a overovani hashovanych hesel.
 *
 * Whole password hash is generated by principle:
 * gen. salt + gen. hash, whole cropped to (length = gen. hash constant length + DIGEST_LENGTH_EXTENSION) bytes.
 *
 * @version 3 - improvement: attacker cannot guess salt length
 */
class PasswordHashing {
    fun createPasswordHash(password: String): String {
        val md: MessageDigest
        md = try {
            MessageDigest.getInstance(DIGEST_ALGORITHM)
        } catch (e: NoSuchAlgorithmException) {
            throw IllegalStateException("error initializing MessageDigest: " + e.message, e)
        }
        // whole password hash length will be md.getDigestLength() + DIGEST_LENGTH_EXTENSION
        val hashLength = md.digestLength + DIGEST_LENGTH_EXTENSION - SALT_LENGTH
        val hpwd = ByteArray(SALT_LENGTH + hashLength)
        val sr: SecureRandom
        sr = try {
            SecureRandom.getInstance("SHA1PRNG")
        } catch (e: NoSuchAlgorithmException) {
            throw IllegalStateException("error initializing SecureRandom: " + e.message, e)
        }
        val salt = ByteArray(SALT_LENGTH)
        sr.nextBytes(salt)
        System.arraycopy(salt, 0, hpwd, 0, SALT_LENGTH) // copy the salt
        md.update(salt)
        val passwordBytes = password.toByteArray(StandardCharsets.UTF_8)
        md.update(hashLength.toByte()) // include hash-length in the hash computation to be able to detect hash truncation
        md.update(passwordBytes)
        val hash = md.digest()
        System.arraycopy(hash, 0, hpwd, SALT_LENGTH, hashLength)
        return Base64.getEncoder().encodeToString(hpwd)
    }

    fun verifyPasswordHash(passwHash: String?, password: String?): Boolean {
        if (passwHash == null || password == null || passwHash.trim { it <= ' ' }.isEmpty()) return false
        val pwdHash = Base64.getDecoder().decode(passwHash.toByteArray(StandardCharsets.UTF_8))
        // check if salt length is too big - either truncated data or some
        if (SALT_LENGTH >= pwdHash.size) // random garbage
            return false
        val md = try {
            MessageDigest.getInstance(DIGEST_ALGORITHM)
        } catch (e: NoSuchAlgorithmException) {
            throw IllegalStateException("error initializing MessageDigest: " + e.message, e)
        }
        // add salt
        md.update(pwdHash, 0, SALT_LENGTH)
        // whole password hash length (pwdHash.length) will be md.getDigestLength() + DIGEST_LENGTH_EXTENSION, where first is salt
        val hashLength = pwdHash.size - SALT_LENGTH
        if (hashLength == 0) // truncated data
            return false
        val passwordBytes = password.toByteArray(StandardCharsets.UTF_8)
        md.update(hashLength.toByte()) // include hash-length in the hash computation to be able to detect hash truncation
        md.update(passwordBytes)
        val hash = md.digest()

        // compare hash result
        for (i in 0 until hashLength) if (hash[i] != pwdHash[SALT_LENGTH + i]) return false
        return true
    }

    companion object {
        // A 64 bits salt is recommended in RSA PKCS5 standard
        private const val SALT_LENGTH = 8

        // whole password hash is generated by principle as described above
        private const val DIGEST_LENGTH_EXTENSION = 3

        // you cannot change this without making all passwords invalid
        private const val DIGEST_ALGORITHM = "SHA-512"
    }
}