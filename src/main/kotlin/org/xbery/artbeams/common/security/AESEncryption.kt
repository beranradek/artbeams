package org.xbery.artbeams.common.security

import java.nio.charset.StandardCharsets
import java.security.SecureRandom
import java.security.spec.KeySpec
import java.util.*
import javax.crypto.Cipher
import javax.crypto.KeyGenerator
import javax.crypto.SecretKey
import javax.crypto.SecretKeyFactory
import javax.crypto.spec.IvParameterSpec
import javax.crypto.spec.PBEKeySpec
import javax.crypto.spec.SecretKeySpec

/**
 * AES encryption/decryption utility.
 * Based on https://www.baeldung.com/java-aes-encryption-decryption.
 *
 * @author Radek Beran
 */
object AESEncryption {
    private const val PASSWORD_BASED_ALGORITHM = "AES/CBC/PKCS5Padding"

    private val SECURE_RANDOM = SecureRandom()

    private val base62 = Base62.createInstance()

    private const val INIT_VECTOR_SIZE = 16

    private const val PASSWORD_ITERATION_COUNT = 65536

    private const val PASSWORD_KEY_LENGTH = 256

    /**
     * Bytes of default application initial vector for encryption.
     * Note: Encryption involves also other "encryption secret and salt".
     */
    private const val DEFAULT_INIT_VECTOR_BYTES: String = "83eR6K7X5Kh923Qa" // 16 bytes

    /**
     * Default application initial vector for encryption.
     */
    val DEFAULT_INIT_VECTOR_SPEC = IvParameterSpec(DEFAULT_INIT_VECTOR_BYTES.toByteArray(StandardCharsets.UTF_8))

    /**
     * AES-encrypt given plain text using given secret and (random) initialization vector.
     * @param plainText encrypted text
     * @param key secret key used for encryption/decryption, e.g. generated by [getKeyFromPassword]
     * @param iv
     * @return
     */
    fun encryptPasswordBased(plainText: String, key: SecretKey, iv: IvParameterSpec = DEFAULT_INIT_VECTOR_SPEC): String {
        return encrypt(PASSWORD_BASED_ALGORITHM, plainText, key, iv)
    }

    /**
     * AES-decrypt given ciphered string using given secret and (random) initialization vector.
     * @param cipherText
     * @param key
     * @param iv initial vector used for encryption/decryption
     * @return
     */
    fun decryptPasswordBased(cipherText: String, key: SecretKey, iv: IvParameterSpec = DEFAULT_INIT_VECTOR_SPEC): String {
        return decrypt(PASSWORD_BASED_ALGORITHM, cipherText, key, iv)
    }

    /**
     * Generates AES secret key based on given password and salt (password-based key derivation function like PBKDF2).
     * @param password
     * @param salt
     * @return
     */
    fun getKeyFromPassword(password: String, salt: String): SecretKey {
        val factory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256")
        val spec: KeySpec = PBEKeySpec(password.toCharArray(), salt.toByteArray(), PASSWORD_ITERATION_COUNT, PASSWORD_KEY_LENGTH)
        return SecretKeySpec(factory.generateSecret(spec).encoded, "AES")
    }

    /**
     * Generates initialization vector (IV) (pseudorandom value).
     * @return
     */
    fun generateIv(): IvParameterSpec {
        val iv = ByteArray(INIT_VECTOR_SIZE)
        SECURE_RANDOM.nextBytes(iv)
        return IvParameterSpec(iv)
    }

    fun encrypt(algorithm: String, input: String, key: SecretKey, iv: IvParameterSpec = DEFAULT_INIT_VECTOR_SPEC): String {
        // Ciphering of bytes padded to multiplies of 16 is supported:
        val paddedInput = padToMultipleOf16(input.toByteArray())
        val cipher = Cipher.getInstance(algorithm)
        cipher.init(Cipher.ENCRYPT_MODE, key, iv)
        val cipherText = cipher.doFinal(paddedInput)
        return String(base62.encode(cipherText))
    }

    fun decrypt(algorithm: String, cipherText: String, key: SecretKey, iv: IvParameterSpec = DEFAULT_INIT_VECTOR_SPEC): String {
        val decoded = base62.decode(cipherText.toByteArray())
        val cipher = Cipher.getInstance(algorithm)
        cipher.init(Cipher.DECRYPT_MODE, key, iv)
        val plainText = cipher.doFinal(decoded)
        val unpaddedPlainText = removePadding(plainText)
        return String(unpaddedPlainText)
    }

    /**
     * Generates random AES secret key with the size of n (128, 192, and 256) bits.
     * @param n
     * @return
     */
    fun generateKey(n: Int): SecretKey {
        val keyGenerator = KeyGenerator.getInstance("AES")
        keyGenerator.init(n)
        val key = keyGenerator.generateKey()
        return key
    }

    @Suppress("MagicNumber")
    private fun padToMultipleOf16(input: ByteArray): ByteArray {
        val paddingLength = 16 - (input.size % 16)
        return input + ByteArray(paddingLength) { paddingLength.toByte() }
    }

    private fun removePadding(input: ByteArray): ByteArray {
        val paddingLength = input.last().toInt()
        return input.copyOfRange(0, input.size - paddingLength)
    }
}
